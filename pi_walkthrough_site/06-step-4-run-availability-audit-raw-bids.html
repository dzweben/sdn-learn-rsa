<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Step 4 – Run availability audit (raw BIDS) – LEARN RSA PI Walkthrough</title>
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
  <div class="layout">
    <nav class="sidebar">
      <div class="site-title">LEARN RSA PI Walkthrough</div>
      <ul class="nav">
  <li class=""><a href="index.html">Overview</a></li>
  <li class=""><a href="02-step-0-map-of-paths-and-environment.html">Step 0 – Map of Paths and Environment</a></li>
  <li class=""><a href="03-step-1-fix-events-nopred-fdbk-relabel.html">Step 1 – Fix events (nopred_fdbk relabel)</a></li>
  <li class=""><a href="04-step-2-generate-run-wise-timing-files-nonpm.html">Step 2 – Generate run-wise timing files (NonPM)</a></li>
  <li class=""><a href="05-step-3-generate-afni-proc-scripts-no-blur-from-raw-bids.html">Step 3 – Generate AFNI proc scripts (no blur) from raw BIDS</a></li>
  <li class="active"><a href="06-step-4-run-availability-audit-raw-bids.html">Step 4 – Run availability audit (raw BIDS)</a></li>
  <li class=""><a href="07-step-5-run-the-full-afni-pipeline-proc-glm-in-tmux.html">Step 5 – Run the full AFNI pipeline (proc + GLM) in tmux</a></li>
  <li class=""><a href="08-step-6-audit-post-run-checks.html">Step 6 – Audit (post-run checks)</a></li>
  <li class=""><a href="09-setback-b-sub-1522-glm-collinearity.html">Setback B – sub-1522 GLM collinearity</a></li>
</ul>
    </nav>
    <main class="content">
      <article>
        <h2 id="step-4-run-availability-audit-raw-bids">Step 4 – Run availability audit (raw BIDS)</h2>
<p>Purpose: verify whether any subjects truly have only 2–3 runs in raw BIDS, before deciding whether a fallback is needed.</p>
<p>Audit command (run on mounted BIDS):</p>
<pre><code class="language-bash">python3 - &lt;&lt;'PY'
import glob, os, re
bids=&quot;/Volumes/Jarcho_DataShare/projects/STUDIES/LEARN/fMRI/bids&quot;
subs=sorted([d for d in glob.glob(os.path.join(bids,&quot;sub-*&quot;)) if os.path.isdir(d)])
missing=[]
for s in subs:
    sid=os.path.basename(s).split(&quot;-&quot;)[1]
    files=glob.glob(os.path.join(s,&quot;func&quot;,f&quot;sub-{sid}_task-learn_run-*_bold.nii.gz&quot;))
    runs=set()
    for f in files:
        m=re.search(r&quot;run-(\\d+)_bold&quot;,f)
        if m:
            runs.add(int(m.group(1)))
    if runs:
        if len(runs) != 4:
            missing.append((sid,sorted(runs)))
    else:
        missing.append((sid,[]))
print(&quot;n_subs&quot;,len(subs))
print(&quot;missing_count&quot;,len(missing))
for sid,runs in missing:
    print(sid, runs)
PY
</code></pre>
<p>Audit result (raw BIDS run files):
- <code>n_subs 55</code>
- <code>missing_count 2</code>
- <code>1165 [1, 2, 3]</code> (missing run 4)
- <code>1274 [1, 2]</code> (missing runs 3–4)</p>
<p>Why this did not necessarily crash earlier runs:
- The <strong>orchestrator script checks run availability</strong> per subject.
- If a subject has <code>&lt;4</code> runs, it <strong>invokes the fallback patcher</strong> to rewrite the proc script with only those runs (so AFNI doesn’t try to load missing data).
- This is why missing‑run subjects can still run without a hard error.</p>
<p><strong>Optional fallback (only if a subject truly has &lt;4 runs)</strong>
The script below shows how a proc would be rewritten to only include the available runs and recompute GLTs. It was kept as a reference.</p>
<details>
<summary>Fallback patch script (example only)</summary>

Script (full): `rsa-learn/scripts/LEARN_ap_fallback_patch_afni_raw.py`

<pre><code class="language-python">#!/usr/bin/env python3
from pathlib import Path
import sys

# Usage: LEARN_ap_fallback_patch_afni_raw.py &lt;ap_tmp&gt; &lt;subj&gt; &lt;runs...&gt;

def main():
    if len(sys.argv) &lt; 4:
        raise SystemExit(&quot;Usage: LEARN_ap_fallback_patch_afni_raw.py &lt;ap_tmp&gt; &lt;subj&gt; &lt;runs...&gt;&quot;)

    ap = Path(sys.argv[1])
    subj = sys.argv[2]
    runs = [int(r) for r in sys.argv[3:] if r.strip().isdigit()]
    if not runs:
        raise SystemExit(&quot;No runs provided&quot;)

    stimdir = &quot;$stimdir&quot;
    subj_dir = &quot;$subj_dir&quot;

    stim_defs = [
        (&quot;NonPM_Mean60_fdkm&quot;, &quot;FBM.Mean60&quot;),
        (&quot;NonPM_Mean60_fdkn&quot;, &quot;FBN.Mean60&quot;),
        (&quot;NonPM_Mean80_fdkm&quot;, &quot;FBM.Mean80&quot;),
        (&quot;NonPM_Mean80_fdkn&quot;, &quot;FBN.Mean80&quot;),
        (&quot;NonPM_Nice60_fdkm&quot;, &quot;FBM.Nice60&quot;),
        (&quot;NonPM_Nice60_fdkn&quot;, &quot;FBN.Nice60&quot;),
        (&quot;NonPM_Nice80_fdkm&quot;, &quot;FBM.Nice80&quot;),
        (&quot;NonPM_Nice80_fdkn&quot;, &quot;FBN.Nice80&quot;),
    ]

    pred_resp = [
        (&quot;Mean60_pred&quot;, &quot;Pred.Mean60&quot;),
        (&quot;Mean60_rsp&quot;, &quot;Resp.Mean60&quot;),
        (&quot;Mean80_pred&quot;, &quot;Pred.Mean80&quot;),
        (&quot;Mean80_rsp&quot;, &quot;Resp.Mean80&quot;),
        (&quot;Nice60_pred&quot;, &quot;Pred.Nice60&quot;),
        (&quot;Nice60_rsp&quot;, &quot;Resp.Nice60&quot;),
        (&quot;Nice80_pred&quot;, &quot;Pred.Nice80&quot;),
        (&quot;Nice80_rsp&quot;, &quot;Resp.Nice80&quot;),
    ]

    text = ap.read_text()
    lines = text.splitlines()

    def replace_block(lines_in, start_key, end_key, new_lines):
        out = []
        i = 0
        while i &lt; len(lines_in):
            line = lines_in[i]
            if start_key in line:
                out.append(line)
                i += 1
                while i &lt; len(lines_in) and end_key not in lines_in[i]:
                    i += 1
                out.extend(new_lines)
                continue
            if end_key in line:
                out.append(line)
                i += 1
                continue
            out.append(line)
            i += 1
        return out

    def replace_stim_times(lines_in, stim_times_lines):
        out = []
        i = 0
        while i &lt; len(lines_in):
            line = lines_in[i]
            if line.lstrip().startswith(&quot;-regress_stim_times&quot;):
                out.append(line)
                i += 1
                while i &lt; len(lines_in) and &quot;-regress_stim_labels&quot; not in lines_in[i]:
                    i += 1
                out.extend(stim_times_lines)
                continue
            out.append(line)
            i += 1
        return out

    def build_dsets():
        out = []
        for r in runs:
            out.append(f&quot;\t\t\t{subj_dir}/func/sub-{subj}_task-learn_run-{r:02d}_bold.nii.gz \\&quot;)
        return out

    stim_times = []
    stim_labels = []
    for r in runs:
        for s, lab in stim_defs:
            stim_times.append(f&quot;\t\t{stimdir}/{s}_run{r}.1D \\&quot;)
            stim_labels.append(f&quot;\t\t{lab}.r{r} \\&quot;)

    for s, lab in pred_resp:
        stim_times.append(f&quot;\t\t{stimdir}/{s}.1D \\&quot;)
        stim_labels.append(f&quot;\t\t{lab} \\&quot;)

    stim_count = len(stim_labels)
    stim_types = [&quot;\t\tAM1 \\&quot;] * stim_count
    basis_multi = [&quot;\t\t'dmBLOCK(0)' \\&quot;] * stim_count

    lines2 = replace_block(lines, &quot;-dsets&quot;, &quot;-scr_overwrite&quot;, build_dsets())
    lines2 = replace_stim_times(lines2, stim_times)
    lines2 = replace_block(lines2, &quot;-regress_stim_labels&quot;, &quot;-regress_stim_types&quot;, stim_labels)
    lines2 = replace_block(lines2, &quot;-regress_stim_types&quot;, &quot;-regress_basis_multi&quot;, stim_types)
    lines2 = replace_block(lines2, &quot;-regress_basis_multi&quot;, &quot;-regress_make_ideal_sum&quot;, basis_multi)

    # Ensure -regress_stim_times exists
    if not any(l.lstrip().startswith(&quot;-regress_stim_times&quot;) for l in lines2):
        for i, l in enumerate(lines2):
            if &quot;-test_stim_files&quot; in l or &quot;-regress_stim_times_offset&quot; in l:
                lines2.insert(i + 1, &quot;\t\t-regress_stim_times \\&quot;)
                break

    def fmt_w(x):
        return &quot;&quot; if abs(x - 1.0) &lt; 1e-8 else f&quot;{x:.6f}*&quot;

    def glt(sym, label, idx):
        return f&quot;\t\t-gltsym 'SYM: {sym}' -glt_label {idx} {label} \\&quot;

    runs_sorted = runs
    num_runs = len(runs_sorted)

    def all_run_terms(peer=None, cond=None):
        terms = []
        for r in runs_sorted:
            if peer and cond:
                terms.append(f&quot;+{peer}.{cond}.r{r}&quot;)
            elif peer:
                for c in [&quot;Mean60&quot;, &quot;Mean80&quot;, &quot;Nice60&quot;, &quot;Nice80&quot;]:
                    terms.append(f&quot;+{peer}.{c}.r{r}&quot;)
            else:
                for p in [&quot;FBM&quot;, &quot;FBN&quot;]:
                    for c in [&quot;Mean60&quot;, &quot;Mean80&quot;, &quot;Nice60&quot;, &quot;Nice80&quot;]:
                        terms.append(f&quot;+{p}.{c}.r{r}&quot;)
        return terms

    glt_lines = []
    idx = 1

    task_terms = all_run_terms() + [
        &quot;+Pred.Mean60&quot;, &quot;+Resp.Mean60&quot;, &quot;+Pred.Mean80&quot;, &quot;+Resp.Mean80&quot;,
        &quot;+Pred.Nice60&quot;, &quot;+Resp.Nice60&quot;, &quot;+Pred.Nice80&quot;, &quot;+Resp.Nice80&quot;,
    ]
    glt_lines.append(glt(&quot; &quot;.join(task_terms), &quot;Task.V.BL&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot;+Pred.Mean60 +Pred.Mean80 +Pred.Nice60 +Pred.Nice80&quot;, &quot;Prediction.V.BL&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot;+Pred.Mean60 +Pred.Mean80 -Pred.Nice60 -Pred.Nice80&quot;, &quot;Prediction.Mean.V.Nice&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot; &quot;.join(all_run_terms()), &quot;FB.V.BL&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot; &quot;.join(all_run_terms(peer=&quot;FBM&quot;)), &quot;FBM.V.BL&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot; &quot;.join(all_run_terms(peer=&quot;FBN&quot;)), &quot;FBN.V.BL&quot;, idx)); idx += 1

    fbm_terms = all_run_terms(peer=&quot;FBM&quot;)
    fbn_terms = [t.replace(&quot;+&quot;, &quot;-&quot;) for t in all_run_terms(peer=&quot;FBN&quot;)]
    glt_lines.append(glt(&quot; &quot;.join(fbm_terms + fbn_terms), &quot;FBM.V.FBN&quot;, idx)); idx += 1

    for r in runs_sorted:
        glt_lines.append(glt(f&quot;+0.5*FBM.Mean60.r{r} +0.5*FBN.Mean60.r{r}&quot;, f&quot;Mean60.r{r}&quot;, idx)); idx += 1
        glt_lines.append(glt(f&quot;+0.5*FBM.Mean80.r{r} +0.5*FBN.Mean80.r{r}&quot;, f&quot;Mean80.r{r}&quot;, idx)); idx += 1
        glt_lines.append(glt(f&quot;+0.5*FBM.Nice60.r{r} +0.5*FBN.Nice60.r{r}&quot;, f&quot;Nice60.r{r}&quot;, idx)); idx += 1
        glt_lines.append(glt(f&quot;+0.5*FBM.Nice80.r{r} +0.5*FBN.Nice80.r{r}&quot;, f&quot;Nice80.r{r}&quot;, idx)); idx += 1

    for r in runs_sorted:
        glt_lines.append(glt(f&quot;+0.25*FBM.Mean60.r{r} +0.25*FBM.Mean80.r{r} +0.25*FBM.Nice60.r{r} +0.25*FBM.Nice80.r{r}&quot;, f&quot;FBM.r{r}&quot;, idx)); idx += 1
        glt_lines.append(glt(f&quot;+0.25*FBN.Mean60.r{r} +0.25*FBN.Mean80.r{r} +0.25*FBN.Nice60.r{r} +0.25*FBN.Nice80.r{r}&quot;, f&quot;FBN.r{r}&quot;, idx)); idx += 1

    wr = 1.0 / num_runs
    for cond in [&quot;Mean60&quot;, &quot;Mean80&quot;, &quot;Nice60&quot;, &quot;Nice80&quot;]:
        fbm = &quot; &quot;.join([f&quot;+{fmt_w(wr)}FBM.{cond}.r{r}&quot; for r in runs_sorted])
        fbn = &quot; &quot;.join([f&quot;+{fmt_w(wr)}FBN.{cond}.r{r}&quot; for r in runs_sorted])
        glt_lines.append(glt(fbm, f&quot;FBM.{cond}.all&quot;, idx)); idx += 1
        glt_lines.append(glt(fbn, f&quot;FBN.{cond}.all&quot;, idx)); idx += 1

    wpr = 1.0 / (2 * num_runs)
    for cond in [&quot;Mean60&quot;, &quot;Mean80&quot;, &quot;Nice60&quot;, &quot;Nice80&quot;]:
        terms = []
        for r in runs_sorted:
            terms.append(f&quot;+{fmt_w(wpr)}FBM.{cond}.r{r}&quot;)
            terms.append(f&quot;+{fmt_w(wpr)}FBN.{cond}.r{r}&quot;)
        glt_lines.append(glt(&quot; &quot;.join(terms), f&quot;{cond}.all&quot;, idx)); idx += 1

    wfb = 1.0 / (4 * num_runs)
    fbm_terms = []
    fbn_terms = []
    for r in runs_sorted:
        for cond in [&quot;Mean60&quot;, &quot;Mean80&quot;, &quot;Nice60&quot;, &quot;Nice80&quot;]:
            fbm_terms.append(f&quot;+{fmt_w(wfb)}FBM.{cond}.r{r}&quot;)
            fbn_terms.append(f&quot;+{fmt_w(wfb)}FBN.{cond}.r{r}&quot;)

    glt_lines.append(glt(&quot; &quot;.join(fbm_terms), &quot;FBM.all&quot;, idx)); idx += 1
    glt_lines.append(glt(&quot; &quot;.join(fbn_terms), &quot;FBN.all&quot;, idx)); idx += 1

    filtered = []
    inserted = False
    for line in lines2:
        if &quot; -num_glt &quot; in line or line.strip().startswith(&quot;-gltsym&quot;) or &quot; -glt_label &quot; in line:
            continue
        filtered.append(line)
        if (not inserted) and line.strip().startswith(&quot;-local_times&quot;):
            filtered.append(f&quot;\t\t-num_glt {len(glt_lines)} \\&quot;)
            filtered.extend(glt_lines)
            inserted = True

    ap.write_text(&quot;\n&quot;.join(filtered) + &quot;\n&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>

</details>
      </article>
      <div class="footer">Generated 2026-02-19 12:05
      </div>
    </main>
  </div>
</body>
</html>
